---
inclusion: always
---

# 设计模式使用指南

## 核心原则

**切勿滥用设计模式**。从实际需求出发，优先选择直接、高效、简洁的代码实现，避免过度设计。

设计模式的正确态度：
- 思想要领要懂
- 优缺点要知
- 使用场景要准

## 模式选择决策

### 何时使用设计模式
- 代码复杂度已经影响可维护性
- 需要解决明确的扩展性问题
- 团队成员都理解该模式

### 何时避免设计模式
- 简单场景用简单代码即可解决
- 为了"面向对象"而使用
- 增加的复杂度超过带来的收益

---

## 一、创建型模式（5种）

### 1.1 工厂方法模式 (Factory Method)

**意图**：定义一个创建对象的接口，让子类决定实例化哪个类。

**描述**：
- 将对象的创建延迟到子类
- 父类定义创建接口，子类实现具体创建逻辑
- 遵循开闭原则，新增产品只需新增子类

**使用规则**：
- ✅ 适用：需要延迟实例化到子类、产品类型可能扩展
- ❌ 避免：简单场景直接 `new` 即可，无需过度封装

---

### 1.2 抽象工厂模式 (Abstract Factory)

**意图**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。

**描述**：
- 创建产品族（多个相关产品）的工厂接口
- 每个具体工厂负责创建一个产品族的所有产品
- 保证产品之间的兼容性

**使用规则**：
- ✅ 适用：需要创建一系列相关产品族、产品族扩展频繁
- ❌ 避免：产品扩展困难（新增产品需修改所有工厂）

---

### 1.3 单例模式 (Singleton)

**意图**：确保一个类只有一个实例，并提供全局访问点。

**描述**：
- 私有构造函数防止外部实例化
- 静态方法提供全局访问
- 延迟初始化或饿汉式初始化

**使用规则**：
- ✅ 适用：全局唯一资源（如配置管理器、日志系统）
- ❌ 避免：优先考虑 VContainer 依赖注入替代，避免隐藏依赖
- ⚠️ Unity注意：考虑 `DontDestroyOnLoad` 和场景切换问题

---

### 1.4 建造者模式 (Builder)

**意图**：将复杂对象的构建与其表示分离，使同样的构建过程可以创建不同的表示。

**描述**：
- 分步骤构建复杂对象
- 支持链式调用 `builder.SetA().SetB().Build()`
- 隔离构建逻辑与业务逻辑

**使用规则**：
- ✅ 适用：复杂对象构建、属性相互依赖、需要不同配置组合
- ❌ 避免：简单对象直接赋值即可

---

### 1.5 原型模式 (Prototype)

**意图**：通过复制现有对象来创建新对象，而不是通过实例化类。

**描述**：
- 实现 `ICloneable` 或自定义克隆方法
- 支持深拷贝和浅拷贝
- 避免重复初始化开销

**使用规则**：
- ✅ 适用：对象创建成本高、需要大量相似对象
- ❌ 避免：克隆逻辑复杂时代码隐晦，需谨慎处理引用类型

---

## 二、结构型模式（7种）

### 2.1 适配器模式 (Adapter)

**意图**：将一个类的接口转换成客户端期望的另一个接口。

**描述**：
- 包装不兼容的接口使其可用
- 类适配器（继承）vs 对象适配器（组合）
- 不修改原有代码实现接口转换

**使用规则**：
- ✅ 适用：接口不兼容需要转换、集成第三方库
- ❌ 避免：能直接使用就别适配，增加间接层

---

### 2.2 装饰器模式 (Decorator)

**意图**：动态地给对象添加额外的职责，比继承更灵活。

**描述**：
- 包装原对象，扩展其功能
- 支持多层装饰叠加
- 遵循开闭原则

**使用规则**：
- ✅ 适用：动态添加功能、功能组合多变
- ❌ 避免：优先考虑继承是否可行，装饰层过多会增加复杂度

---

### 2.3 代理模式 (Proxy)

**意图**：为其他对象提供一种代理以控制对这个对象的访问。

**描述**：
- 远程代理：隐藏网络通信细节
- 虚拟代理：延迟加载大对象
- 保护代理：权限控制

**使用规则**：
- ✅ 适用：控制访问、延迟加载、权限控制、日志记录
- ❌ 避免：增加代码复杂度，简单场景无需代理

---

### 2.4 外观模式 (Facade)

**意图**：为子系统中的一组接口提供一个统一的高层接口。

**描述**：
- 简化复杂子系统的使用
- 提供统一入口点
- 降低客户端与子系统的耦合

**使用规则**：
- ✅ 适用：简化复杂子系统接口、提供统一API
- ❌ 避免：注意开闭原则，外观类不应过于庞大

---

### 2.5 桥接模式 (Bridge)

**意图**：将抽象部分与实现部分分离，使它们可以独立变化。

**描述**：
- 抽象与实现解耦
- 支持多维度扩展
- 组合优于继承

**使用规则**：
- ✅ 适用：抽象与实现需要独立变化、避免类爆炸
- ❌ 避免：复杂度高，简单场景不要使用

---

### 2.6 组合模式 (Composite)

**意图**：将对象组合成树形结构以表示"部分-整体"的层次结构。

**描述**：
- 统一处理单个对象和组合对象
- 递归结构
- 适合树形数据结构

**使用规则**：
- ✅ 适用：树形结构、部分-整体关系、UI层级
- ❌ 避免：复杂度高，谨慎使用

---

### 2.7 享元模式 (Flyweight)

**意图**：运用共享技术有效地支持大量细粒度的对象。

**描述**：
- 分离内部状态（共享）和外部状态（不共享）
- 通过工厂管理共享对象池
- 减少内存占用

**使用规则**：
- ✅ 适用：大量相似对象共享、内存优化
- ❌ 避免：分离内外状态增加复杂度，不利于多线程

---

## 三、行为型模式（11种）

### 3.1 观察者模式 (Observer)

**意图**：定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会收到通知。

**描述**：
- 发布-订阅机制
- 解耦事件发送者和接收者
- 支持动态添加/移除观察者

**使用规则**：
- ✅ 适用：一对多依赖、事件通知、UI与逻辑解耦
- ✅ Unity推荐：配合 R3/UniRx 或 C# event 使用
- ❌ 避免：观察者过多时注意性能和内存泄漏

---

### 3.2 策略模式 (Strategy)

**意图**：定义一系列算法，封装每个算法，并使它们可以互换。

**描述**：
- 算法族封装为独立类
- 运行时动态切换算法
- 消除条件分支

**使用规则**：
- ✅ 适用：运行时切换算法、多种行为变体
- ❌ 避免：简单场景用 `switch-case` 即可

---

### 3.3 命令模式 (Command)

**意图**：将请求封装为对象，从而支持参数化、队列化、撤销/重做等操作。

**描述**：
- 请求封装为命令对象
- 支持撤销/重做（Undo/Redo）
- 支持命令队列和宏命令

**使用规则**：
- ✅ 适用：撤销/重做、请求队列、编辑器操作
- ❌ 避免：简单场景用 `switch-case` 或直接调用

---

### 3.4 状态模式 (State)

**意图**：允许对象在内部状态改变时改变其行为。

**描述**：
- 状态封装为独立类
- 状态转换逻辑清晰
- 消除大量条件判断

**使用规则**：
- ✅ 适用：行为随状态变化、复杂状态机、AI行为
- ❌ 避免：状态少时用枚举 + `switch` 即可

---

### 3.5 责任链模式 (Chain of Responsibility)

**意图**：使多个对象都有机会处理请求，将这些对象连成一条链。

**描述**：
- 请求沿链传递直到被处理
- 解耦请求发送者和接收者
- 动态组合处理链

**使用规则**：
- ✅ 适用：多处理器链式处理、审批流程、事件冒泡
- ❌ 避免：场景固定时按需使用，链过长影响性能

---

### 3.6 模板方法模式 (Template Method)

**意图**：定义算法骨架，将某些步骤延迟到子类实现。

**描述**：
- 父类定义算法框架（模板方法）
- 子类实现具体步骤（抽象方法/虚方法）
- 控制反转：父类调用子类

**使用规则**：
- ✅ 适用：算法骨架固定、步骤可变、代码复用
- ❌ 避免：打破自顶向下阅读习惯，继承层次过深

---

### 3.7 迭代器模式 (Iterator)

**意图**：提供一种方法顺序访问聚合对象中的各个元素，而不暴露其内部表示。

**描述**：
- 统一遍历接口
- 支持多种遍历方式
- 解耦集合与遍历逻辑

**使用规则**：
- ✅ 适用：自定义集合遍历
- ❌ 避免：C# 已内置 `IEnumerable`/`IEnumerator`，通常无需自实现

---

### 3.8 中介者模式 (Mediator)

**意图**：用一个中介对象封装一系列对象的交互。

**描述**：
- 集中管理对象间通信
- 减少对象间直接依赖
- 简化多对多关系为一对多

**使用规则**：
- ✅ 适用：多对象复杂交互、UI组件通信
- ❌ 避免：中介者易膨胀成"上帝类"，难维护

---

### 3.9 备忘录模式 (Memento)

**意图**：在不破坏封装的前提下，捕获对象的内部状态并在之后恢复。

**描述**：
- 保存对象状态快照
- 支持状态回滚
- 不暴露对象内部结构

**使用规则**：
- ✅ 适用：保存/恢复对象状态、游戏存档、编辑器撤销
- ❌ 避免：强相关逻辑分散，频繁保存消耗内存

---

### 3.10 访问者模式 (Visitor)

**意图**：在不改变数据结构的前提下，定义作用于其元素的新操作。

**描述**：
- 将操作与数据结构分离
- 支持双分派
- 易于添加新操作

**使用规则**：
- ✅ 适用：对固定结构执行多种操作、编译器AST遍历
- ❌ 避免：增加新元素困难，违反开闭原则

---

### 3.11 解释器模式 (Interpreter)

**意图**：给定一门语言，定义其文法表示，并定义一个解释器来解释语言中的句子。

**描述**：
- 定义语法规则的类层次
- 递归解释语法树
- 适合简单DSL

**使用规则**：
- ✅ 适用：语法解析、DSL实现、表达式求值
- ❌ 避免：复杂文法导致类层次复杂，性能较差

---

## 四、游戏开发专用模式

### 4.1 游戏循环模式 (Game Loop)

**意图**：将游戏时间的推进与用户输入和处理器速度解耦。

**描述**：
- 游戏循环持续运行，每帧执行：处理输入 → 更新状态 → 渲染画面
- 跟踪时间流逝，控制游戏节奏
- 支持固定时间步长或可变时间步长

**使用规则**：
- ✅ Unity内置：`Update()`、`FixedUpdate()`、`LateUpdate()` 已实现
- ⚠️ 注意：理解 `Time.deltaTime` 和 `Time.fixedDeltaTime` 的区别

---

### 4.2 对象池模式 (Object Pool)

**意图**：通过重用固定池中的对象来提升性能和优化内存使用。

**描述**：
- 预先创建对象集合，标记"使用中/未使用"状态
- 需要对象时从池中获取，用完归还
- 避免频繁的内存分配和GC

**使用规则**：
- ✅ 适用：
  - 频繁创建销毁对象（子弹、特效、敌人）
  - 对象大小相近
  - 堆分配慢或导致内存碎片
- ✅ Unity推荐：配合 `ObjectPool<T>` 或自定义池使用
- ❌ 避免：对象生命周期长、创建不频繁时无需池化

---

### 4.3 组件模式 (Component)

**意图**：允许单个实体跨越多个领域，而不会导致领域间耦合。

**描述**：
- 实体 = 组件容器
- 每个组件负责单一领域（渲染、物理、AI等）
- 组合优于继承

**使用规则**：
- ✅ Unity核心：`MonoBehaviour` 组件系统
- ✅ 适用：
  - 类涉及多个领域需要解耦
  - 类规模庞大难以管理
  - 需要灵活组合不同功能
- ⚠️ 注意：保持组件精简，复杂逻辑移至纯C#类

---

### 4.4 事件队列模式 (Event Queue)

**意图**：对消息或事件的发送与接收进行时间上的解耦。

**描述**：
- FIFO队列存储事件/请求
- 发送方入队后立即返回
- 接收方在合适时机处理队列

**使用规则**：
- ✅ 适用：
  - 需要时间解耦（发送和处理不同步）
  - 推模型（发送方）与拉模型（接收方）结合
  - 音频系统、网络消息处理
- ❌ 避免：
  - 仅需解耦发送/接收者时，用观察者或命令模式
  - 发送方需要即时响应时不适合

---

### 4.5 服务定位器模式 (Service Locator)

**意图**：提供服务的全局访问点，而不将用户耦合到具体实现类。

**描述**：
- 服务接口定义抽象操作
- 服务定位器管理服务注册和查找
- 运行时动态绑定具体实现

**使用规则**：
- ✅ 适用：
  - 全局服务（日志、音频、网络）
  - 需要运行时切换实现
  - 避免深层参数传递
- ❌ 避免：
  - 隐藏依赖关系，难以调试
  - 优先考虑 VContainer 依赖注入
- ⚠️ Unity示例：`GetComponent<T>()` 结合了服务定位器和组件模式

---

### 4.6 脏标记模式 (Dirty Flag)

**意图**：通过将工作推迟到必要时执行，避免不必要的计算。

**描述**：
- 原始数据变化时设置"脏"标记
- 需要派生数据时检查标记
- 标记为脏则重新计算，否则使用缓存

**使用规则**：
- ✅ 适用：
  - 昂贵的计算开销（矩阵变换、路径计算）
  - 昂贵的同步开销（网络同步、文件写入）
  - 原始数据变化频率低于派生数据使用频率
- ❌ 避免：
  - 原始数据变化频繁时，标记频繁失效
  - 增加代码复杂度，仅在性能瓶颈时使用

---

### 4.7 数据局部性模式 (Data Locality)

**意图**：通过合理组织数据，利用CPU缓存机制加快内存访问速度。

**描述**：
- 将频繁一起访问的数据放在连续内存中
- 按处理顺序排列数据
- 提高缓存命中率

**使用规则**：
- ✅ 适用：
  - 性能关键代码
  - 大量数据处理（粒子系统、物理模拟）
  - 确认性能问题由缓存未命中引起
- ✅ Unity/DOTS：ECS架构天然支持数据局部性
- ❌ 避免：
  - 牺牲代码可读性和灵活性
  - 非热点代码无需优化

---

### 4.8 子类沙盒模式 (Subclass Sandbox)

**意图**：使用基类提供的操作集合来定义子类中的行为。

**描述**：
- 基类定义抽象沙盒方法和受保护的操作集合
- 子类只能使用基类提供的操作实现沙盒方法
- 限制子类的能力范围，降低耦合

**使用规则**：
- ✅ 适用：
  - 基类和多个派生类
  - 基类能提供子类所需的所有操作
  - 子类间存在行为重叠，需要共享代码
  - 减少派生类与系统其他部分的耦合
- ❌ 避免：子类需要基类未提供的操作时

---

### 4.9 类型对象模式 (Type Object)

**意图**：通过创建一个类来支持新类型的灵活创建，每个实例代表不同的对象类型。

**描述**：
- 类型对象类：每个实例代表一种逻辑类型
- 类型化对象类：持有类型对象的引用
- 共享数据存储在类型对象中，实例数据存储在类型化对象中

**使用规则**：
- ✅ 适用：
  - 事先不知道需要哪些类型（如怪物种类）
  - 需要在不重新编译的情况下添加新类型
  - 数据驱动的类型定义
- ❌ 避免：类型固定且数量少时，直接用继承

---

## 五、SOLID 设计原则

| 原则 | 全称 | 核心要点 |
|------|------|----------|
| SRP | 单一职责原则 | 一个类只负责一件事，只有一个修改理由 |
| OCP | 开闭原则 | 对扩展开放，对修改关闭；通过抽象和多态扩展 |
| LSP | 里氏替换原则 | 子类必须能替换父类使用，不改变程序正确性 |
| ISP | 接口隔离原则 | 接口要小而专，客户端不依赖不需要的方法 |
| DIP | 依赖倒置原则 | 高层模块不依赖低层模块，都依赖抽象 |

### 迪米特法则 (LoD)
又称最少知识原则：一个对象应尽量少地了解其他对象。
- 只与直接朋友通信（成员变量、方法参数、返回值）
- 不要链式调用陌生对象：`a.GetB().GetC().DoSomething()` ❌
- 降低耦合度，提高模块独立性

---

## 六、重构指南

### 何时重构
- 代码异味（Code Smell）出现时
- 添加新功能前，先重构使其更易扩展
- 修复 Bug 时，顺便改善代码结构
- Code Review 发现问题时

### 常见重构手法
| 手法 | 适用场景 |
|------|----------|
| 提取方法 | 方法过长、重复代码 |
| 提取类 | 类职责过多、违反 SRP |
| 内联方法/类 | 过度抽象、间接层无意义 |
| 移动方法/字段 | 功能放错了类 |
| 重命名 | 名称不能表达意图 |
| 引入参数对象 | 参数过多 |
| 以多态取代条件 | 大量 if-else/switch 判断类型 |
| 提取接口 | 需要解耦或支持多实现 |

### 重构原则
- 小步前进，每次只做一件事
- 保持测试通过，重构不改变外部行为
- 先写测试，再重构
- 不要同时重构和添加功能

---

## 七、Unity 项目特别建议

### 推荐使用
- **对象池**：GameObject 频繁创建销毁场景
- **观察者/事件**：UI 与逻辑解耦、跨系统通信（配合 R3/MessagePipe）
- **命令模式**：编辑器撤销/重做功能
- **状态模式**：复杂的 AI 状态机、动画状态
- **组件模式**：Unity 核心架构，保持组件精简

### 谨慎使用
- **单例**：考虑 VContainer 依赖注入替代
- **工厂**：Unity 有 `Instantiate`，按需封装
- **MVC/MVP**：现代 UI 框架已内置类似思想

### 性能优化相关
- **数据局部性**：配合 DOTS/ECS 使用
- **脏标记**：矩阵变换、路径计算等昂贵操作
- **对象池**：减少 GC 压力

---

## 八、代码质量检查清单

生成代码时自问：
1. 这个模式解决了什么具体问题？
2. 不用这个模式，代码会有什么问题？
3. 使用后代码是否更易读、更易维护？
4. 团队成员能否理解这个实现？
