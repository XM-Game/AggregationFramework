# UniTask Runtime Internal 功能自述

本文档描述了 UniTask 运行时内部模块（Internal）中各个组件的功能和作用。这些组件是 UniTask 框架的核心基础设施，为上层 API 提供性能优化、内存管理和执行调度等关键功能。

## 目录

- [内存管理组件](#内存管理组件)
- [执行调度组件](#执行调度组件)
- [工具类组件](#工具类组件)
- [诊断和调试组件](#诊断和调试组件)
- [Unity 专用组件](#unity-专用组件)

---

## 内存管理组件

### ArrayPool（数组对象池）

提供线程安全的数组对象池实现，用于减少数组分配和垃圾回收压力。该组件实现了与 System.Buffers.ArrayPool 相同的接口，但仅提供共享实例。

**主要特性：**
- 使用分桶策略管理不同大小的数组（8 到 1048576 字节）
- 每个桶使用自旋锁保证线程安全
- 自动将请求的数组大小向上取整到最近的 2 的幂次方
- 限制每个桶的最大数组数量，防止内存无限增长

**使用场景：**
- 频繁创建和销毁数组的场景
- 需要减少 GC 分配的高性能代码路径

### ArrayPoolUtil（数组池工具类）

提供基于数组池的数组容量管理和集合物化功能。

**主要功能：**
- 动态扩展数组容量，使用数组池进行内存管理
- 将 IEnumerable 集合物化为数组，避免不必要的内存拷贝
- 提供 RentArray 结构体，自动管理数组的租借和归还

**优化特性：**
- 智能判断类型是否包含引用，决定是否需要清空数组
- 支持集合大小预判，减少扩容次数

### ArrayUtil（数组工具类）

提供不依赖对象池的数组工具方法，适用于不需要对象池的场景。

**主要功能：**
- 数组容量动态扩展
- 集合物化为数组，避免 ToArray 的额外拷贝开销

### StatePool（状态元组池）

提供 1 到 3 个元素的元组对象池，用于减少状态对象的分配。

**主要特性：**
- 支持 StateTuple<T1>、StateTuple<T1, T2>、StateTuple<T1, T2, T3> 三种元组类型
- 使用并发队列实现线程安全的对象池
- 元组实现 IDisposable 接口，支持自动归还到对象池

**使用场景：**
- 异步状态机中需要传递多个状态值
- 需要频繁创建和销毁元组对象的场景

### PooledDelegate（池化委托）

提供委托的对象池包装，减少委托分配开销。

**主要特性：**
- 将 Action 委托包装为 Action<T>，使用对象池管理
- 委托执行后自动归还到对象池
- 支持泛型类型，每种类型有独立的对象池

---

## 执行调度组件

### ContinuationQueue（延续队列）

管理在 Unity PlayerLoop 不同阶段执行的延续回调队列。

**主要特性：**
- 支持 Unity PlayerLoop 的所有阶段（Initialization、Update、FixedUpdate、LateUpdate 等）
- 使用双缓冲机制，在执行时收集新的回调到等待队列
- 线程安全的入队操作，使用自旋锁保护
- 异常安全，单个回调的异常不会影响其他回调执行

**执行流程：**
- 在 Unity PlayerLoop 的指定阶段被调用
- 执行当前队列中的所有回调
- 将等待队列与当前队列交换，准备下一帧执行

### PlayerLoopRunner（PlayerLoop 运行器）

在 Unity 主循环中执行实现了 IPlayerLoopItem 接口的任务。

**主要特性：**
- 支持 Unity PlayerLoop 的所有阶段
- 使用数组存储任务，支持动态扩容
- 任务执行失败时自动移除，不会阻塞后续任务
- 使用等待队列处理运行期间添加的新任务
- 异常处理机制，确保单个任务的异常不会影响整体执行

**执行策略：**
- 从数组头部开始执行任务
- 任务完成后（MoveNext 返回 false）标记为 null
- 使用从尾部向前查找的方式填充 null 位置，保持数组紧凑

### MinimumQueue（最小化队列）

优化的队列实现，相比标准 Queue<T> 减少了不必要的开销。

**主要特性：**
- 使用循环数组实现，支持动态扩容
- 使用头尾指针管理队列，避免数组元素移动
- 增长因子为 200%，最小增长为 4 个元素

---

## 工具类组件

### Error（错误处理工具）

提供统一的错误抛出方法，使用内联优化减少调用开销。

**主要功能：**
- 参数空值检查
- 参数范围检查
- 集合操作错误（空集合、多元素等）
- 异步操作状态检查（未完成、延续已注册等）
- 操作取消异常

**优化特性：**
- 使用 MethodImpl 特性控制内联行为
- 常见检查路径使用内联，异常路径不使用内联

### RuntimeHelpersAbstraction（运行时辅助抽象）

提供类型信息查询功能，判断类型是否包含引用。

**主要功能：**
- 判断类型是否为值类型且不包含引用
- 支持基本类型、枚举、DateTime、Guid、decimal 等
- 支持 Unity 类型（Vector2/3/4、Color、Rect、Bounds、Quaternion 等）
- 支持可空类型和泛型参数

**使用场景：**
- 决定数组归还到对象池时是否需要清空
- 优化内存操作，避免不必要的清空操作

### ValueStopwatch（值类型秒表）

高性能的时间测量工具，使用值类型避免堆分配。

**主要特性：**
- 基于 Stopwatch 的高精度时间测量
- 值类型实现，零分配
- 提供经过的时间（TimeSpan）和滴答数（Ticks）

---

## 诊断和调试组件

### DiagnosticsExtensions（诊断扩展）

提供异步堆栈跟踪的清理和美化功能。

**主要功能：**
- 清理异步状态机生成的复杂堆栈跟踪
- 美化类型名称，移除泛型标记和命名空间前缀
- 识别并标记异步方法
- 解析状态机方法，还原原始方法名
- 生成 Unity 编辑器可点击的代码链接

**美化规则：**
- 将内置类型转换为简短名称（如 System.Int32 → int）
- 移除 UniTask 相关的命名空间前缀
- 过滤系统内部方法（ExecutionContext、CompilerServices 等）
- 支持泛型类型的美化显示

### TaskTracker（任务跟踪器）

在 Unity 编辑器中跟踪活动的 UniTask 任务，用于调试和性能分析。

**主要功能：**
- 跟踪所有活动的 UniTask 任务
- 记录任务的创建时间、类型和堆栈跟踪
- 提供任务状态查询（Pending、Succeeded、Faulted、Canceled）
- 支持启用/禁用跟踪和堆栈跟踪收集

**编辑器集成：**
- 与 UniTaskTrackerWindow 窗口集成
- 支持自动刷新和手动刷新
- 可配置的跟踪选项（自动重载、启用跟踪、启用堆栈跟踪）

---

## Unity 专用组件

### UnityEqualityComparer（Unity 相等比较器）

为 Unity 常用类型提供专门的相等比较器实现。

**支持的类型：**
- Vector2、Vector3、Vector4
- Vector2Int、Vector3Int（Unity 2017.2+）
- Color、Color32
- Rect、RectInt（Unity 2017.2+）
- Bounds、BoundsInt（Unity 2017.2+）
- Quaternion
- RangeInt（Unity 2017.2+）

**主要特性：**
- 使用类型缓存，避免重复创建比较器
- 针对 Unity 类型的哈希码计算优化
- 支持通过泛型方法获取默认比较器

### UnityWebRequestExtensions（Unity WebRequest 扩展）

提供 Unity WebRequest 的错误检查扩展方法。

**主要功能：**
- 统一不同 Unity 版本的错误检查接口
- 兼容 Unity 2020.2 之前和之后的 API 差异
- 检查连接错误、数据处理错误和协议错误

### WeakDictionary（弱引用字典）

使用弱引用存储键的字典实现，不会阻止键对象被垃圾回收。

**主要特性：**
- 线程安全的操作（使用自旋锁）
- 自动清理已回收的键值对（sweep 机制）
- 支持动态扩容，使用哈希表实现
- 可配置的负载因子

**使用场景：**
- 需要跟踪对象但不影响其生命周期的场景
- 任务跟踪器中使用，避免内存泄漏

---

## 总结

UniTask Runtime Internal 模块提供了完整的基础设施支持，包括：

1. **性能优化**：通过对象池、值类型、内联优化等手段减少分配和提升性能
2. **内存管理**：智能的数组和对象池管理，减少 GC 压力
3. **执行调度**：与 Unity PlayerLoop 深度集成，提供精确的执行时机控制
4. **调试支持**：完善的诊断和跟踪工具，便于开发和问题排查
5. **Unity 集成**：针对 Unity 类型的专门优化和支持

这些组件共同构成了 UniTask 框架的坚实基础，为上层的异步编程 API 提供了高效、可靠的运行时支持。

