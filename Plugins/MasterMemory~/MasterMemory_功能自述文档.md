# MasterMemory 内存数据库框架功能自述文档

## 概述

MasterMemory 是一个专为 C# 和 Unity 设计的高性能内存数据库框架。它提供了完全不可变的内存数据库实现，通过源代码生成技术自动创建强类型的表和数据库类。框架采用 MessagePack 进行高效的二进制序列化，支持数据验证、索引查询、范围查找等丰富的数据库功能。MasterMemory 的设计理念是提供类型安全、性能优异、易于使用的内存数据库解决方案，特别适合游戏开发、配置数据管理、静态数据查询等场景。

## 核心特性

### 一、不可变内存数据库

MasterMemory 的核心是提供完全不可变的内存数据库实现：

#### 1. 数据不可变性
所有存储在内存数据库中的数据都是不可变的，一旦数据库构建完成，数据无法被修改。这种设计确保了数据的一致性和线程安全性，避免了并发访问时的数据竞争问题。

#### 2. 内存高效存储
数据以紧凑的二进制格式存储在内存中，使用 MessagePack 序列化技术，支持 LZ4 压缩，大幅减少内存占用。数据库可以直接从字节数组加载，无需复杂的反序列化过程。

#### 3. 零拷贝访问
通过精心设计的数据结构，支持直接访问原始数据数组，避免了额外的内存拷贝和对象分配，提供了接近原生数组访问的性能。

#### 4. 并行加载支持
数据库支持并行加载模式，可以通过配置最大并行度来控制数据表的加载速度，充分利用多核 CPU 的性能优势。

### 二、源代码生成系统

MasterMemory 使用 Roslyn 源代码生成器技术，自动生成所有必要的代码：

#### 1. 表类生成
为每个标记了 `MemoryTableAttribute` 的数据类型自动生成强类型的表类。生成的表类提供了基于主键和次键的查询方法，所有查询都是类型安全的。

#### 2. 数据库类生成
自动生成数据库类，作为所有表的容器。数据库类提供了统一的接口来访问所有表，支持从字节数组或流中加载数据。

#### 3. 数据库构建器生成
自动生成数据库构建器类，用于构建数据库实例。构建器提供了 `Append` 方法来添加表数据，自动处理数据排序和索引构建，最终生成可序列化的数据库二进制数据。

#### 4. 不可变构建器生成
自动生成不可变构建器类，支持增量更新数据库。不可变构建器提供了 `Remove` 和 `Diff` 方法，可以基于现有数据库创建新的数据库实例，而不修改原始数据。

#### 5. MessagePack 解析器生成
自动生成 MessagePack 解析器，确保所有数据类型的序列化和反序列化都有最优的实现，支持自定义格式化器和解析器配置。

#### 6. 命名空间和类名前缀配置
支持通过生成器选项配置生成的命名空间和类名前缀，提供了灵活的代码组织方式。

### 三、索引系统

MasterMemory 提供了强大的索引系统，支持高效的查询操作：

#### 1. 主键索引
每个表必须定义主键（Primary Key），使用 `PrimaryKeyAttribute` 标记。主键可以是单个属性或多个属性的组合，通过 `KeyOrder` 参数指定键的顺序。主键必须唯一，用于精确查找操作。

#### 2. 次键索引
支持定义多个次键索引（Secondary Index），使用 `SecondaryKeyAttribute` 标记。次键索引通过 `IndexNo` 参数区分不同的索引，同样支持多属性组合索引。次键可以是唯一的或非唯一的，使用 `NonUniqueAttribute` 标记非唯一索引。

#### 3. 自动排序
所有索引数据在构建时自动按照索引键进行排序，确保查询时可以使用高效的二分查找算法。排序使用指定的比较器，支持自定义比较逻辑。

#### 4. 字符串比较选项
支持通过 `StringComparisonOptionAttribute` 配置字符串字段的比较方式，可以选择不同的字符串比较规则（如大小写敏感、文化相关等）。

#### 5. 整数键优化
对于整数类型的主键，框架提供了专门的优化路径，使用内联比较操作，进一步提升查询性能。

### 四、查询功能

MasterMemory 提供了丰富的查询功能，所有查询都是类型安全和高效的：

#### 1. 唯一键查询
支持通过主键或唯一次键进行精确查找。提供了 `Find` 方法（查找失败时抛出异常）和 `TryFind` 方法（查找失败时返回 false）。支持查找最接近的键值，可以选择向上或向下查找。

#### 2. 批量查询
支持通过非唯一键查询多个匹配的记录。使用 `FindMany` 方法返回所有匹配的记录范围视图。支持查找最接近的键值对应的所有记录。

#### 3. 范围查询
支持范围查询，可以查询键值在指定范围内的所有记录。范围查询支持升序和降序排列，可以灵活指定最小值和最大值。

#### 4. 范围视图
所有查询结果都返回 `RangeView` 类型，这是一个轻量级的只读视图，提供了类似列表的接口。范围视图支持枚举、索引访问、反转等操作，但不会复制底层数据，保持了高效的内存使用。

#### 5. 全量访问
每个表都提供了 `All` 和 `AllReverse` 属性，可以访问表中的所有数据，支持正向和反向枚举。

#### 6. 原始数据访问
提供了 `GetRawDataUnsafe` 方法，可以获取表的原始数据数组，用于需要直接访问数据的特殊场景。

### 五、数据验证系统

MasterMemory 提供了完整的数据验证框架，确保数据的完整性和正确性：

#### 1. 验证接口
数据类可以实现 `IValidatable<T>` 接口，在验证过程中执行自定义的验证逻辑。验证器提供了丰富的验证方法和辅助工具。

#### 2. 唯一性验证
支持验证字段的唯一性约束，可以验证单个字段或多个字段组合的唯一性。支持自定义相等比较器，灵活控制唯一性判断规则。

#### 3. 引用完整性验证
提供了 `ReferenceSet` 类型，用于验证外键引用的完整性。可以验证当前记录引用的值是否在关联表中存在，支持跨表验证。

#### 4. 表集合验证
提供了 `ValidatableSet` 类型，用于对表数据进行集合级别的验证。支持过滤、唯一性验证等操作，可以链式调用多个验证方法。

#### 5. 表达式验证
支持使用表达式树进行验证，验证器会自动提取表达式中涉及的成员值，生成详细的错误信息。表达式验证提供了类型安全和编译时检查的优势。

#### 6. 验证结果
所有验证错误都会收集到 `ValidateResult` 对象中，包含了错误类型、错误消息和相关的数据对象。提供了格式化输出方法，方便调试和日志记录。

#### 7. 主键信息
验证错误信息中会自动包含主键信息，方便定位问题数据。支持在验证过程中获取当前记录的主键值。

#### 8. 一次性验证
支持使用 `CallOnce` 方法确保某些验证逻辑只执行一次，避免重复验证造成的性能问题。

### 六、二进制搜索优化

MasterMemory 内部使用高效的二分查找算法，提供了多种查找变体：

#### 1. 精确查找
`FindFirst` 方法用于查找第一个匹配的键值，使用标准的二分查找算法。

#### 2. 下界查找
`LowerBound` 方法查找第一个大于或等于指定键值的索引位置，用于范围查询的起始位置确定。

#### 3. 上界查找
`UpperBound` 方法查找第一个大于指定键值的索引位置，用于范围查询的结束位置确定。

#### 4. 最接近查找
`FindClosest` 方法查找最接近指定键值的位置，可以选择向上或向下查找。用于查找最接近的记录。

#### 5. 边界查找
`LowerBoundClosest` 和 `UpperBoundClosest` 方法用于范围查询，查找满足范围条件的最接近边界位置。

#### 6. 整数键优化
对于整数类型键，提供了专门的 `FindFirstIntKey` 方法，使用内联比较操作，避免函数调用开销。

### 七、数据构建和序列化

MasterMemory 提供了灵活的数据构建和序列化机制：

#### 1. 数据库构建
使用数据库构建器类构建数据库，通过 `Append` 方法添加表数据。构建器自动处理数据排序、索引构建和序列化，最终生成紧凑的二进制数据。

#### 2. MessagePack 序列化
使用 MessagePack 进行二进制序列化，提供了高效的序列化和反序列化性能。支持 LZ4 压缩，可以大幅减少数据大小。

#### 3. 流式写入
支持将数据库写入到流中，可以写入到文件、网络流等各种目标。提供了灵活的 I/O 操作接口。

#### 4. 字节数组构建
支持直接构建为字节数组，方便内存操作和传输。构建的字节数组包含头部信息和表数据，结构紧凑。

#### 5. 自定义序列化选项
支持自定义 MessagePack 序列化选项，包括自定义格式化器、解析器等。可以在构建和加载时分别配置序列化选项。

#### 6. 字符串内化
支持字符串内化选项，可以将重复的字符串引用到字符串池中，减少内存占用。内化是可选的，可以根据数据特征选择启用。

#### 7. 动态追加
提供了 `AppendDynamic` 扩展方法，支持在运行时动态追加表数据，提供了灵活的构建方式。

### 八、不可变构建器

MasterMemory 提供了不可变构建器，支持增量更新数据库：

#### 1. 移除操作
提供了 `Remove` 方法，可以根据指定的键值列表移除记录，生成新的数据库实例。移除操作不会修改原始数据库。

#### 2. 差异更新
提供了 `Diff` 方法，可以基于现有数据库和新的数据集合，计算差异并生成更新的数据库实例。差异更新会替换匹配的记录，添加新记录，保留未匹配的原有记录。

#### 3. 克隆和排序
不可变构建器内部使用克隆和排序操作，确保新数据库的数据正确排序和索引。所有操作都是高效的，避免了不必要的数据复制。

### 九、元数据系统

MasterMemory 提供了元数据系统，支持运行时查询数据库结构：

#### 1. 数据库元数据
`MetaDatabase` 类提供了数据库级别的元数据访问，可以查询数据库中的所有表信息。

#### 2. 表元数据
`MetaTable` 类提供了表级别的元数据，包括数据类型、表类型、表名、属性列表、索引列表等信息。

#### 3. 属性元数据
`MetaProperty` 类提供了属性级别的元数据，包括属性信息、名称转换（驼峰命名、蛇形命名等）。

#### 4. 索引元数据
`MetaIndex` 类提供了索引级别的元数据，包括索引属性、是否为主索引、是否唯一、比较器等信息。

#### 5. 表信息查询
提供了 `GetTableInfo` 静态方法，可以从数据库二进制数据中提取表信息，无需完全加载数据库。支持 JSON 转储功能，方便调试和查看数据结构。

### 十、Unity 集成

MasterMemory 针对 Unity 平台进行了特殊优化：

#### 1. IL2CPP 兼容
完全兼容 Unity 的 IL2CPP 编译后端，可以在所有 Unity 支持的平台上使用，包括移动平台和游戏主机。

#### 2. AOT 支持
支持 AOT（Ahead-of-Time）编译，可以在不支持 JIT 的平台上使用。源代码生成确保了所有必要的代码都在编译时生成。

#### 3. 性能优化
针对 Unity 的性能特性进行了优化，减少了内存分配和垃圾回收压力。使用高效的数据结构和算法，确保在移动设备上也有良好的性能表现。

#### 4. 编辑器集成
提供了 Unity 编辑器集成，可以在编辑器中构建和验证数据库，方便开发工作流。

## 技术架构

### 1. 核心组件

#### MemoryDatabaseBase
数据库的抽象基类，提供了数据库的基本功能，包括数据加载、表信息提取、数据验证等。所有生成的数据库类都继承自这个基类。

#### TableBase
表的抽象基类，提供了表的通用功能，包括查询方法、验证方法、工具方法等。所有生成的表类都继承自这个基类，使用泛型提供类型安全。

#### DatabaseBuilderBase
数据库构建器的抽象基类，提供了构建数据库的核心功能，包括数据追加、排序、序列化等。所有生成的构建器类都继承自这个基类。

#### ImmutableBuilderBase
不可变构建器的抽象基类，提供了增量更新数据库的功能，包括移除、差异计算等。所有生成的不可变构建器类都继承自这个基类。

#### RangeView
范围视图结构体，提供了查询结果的视图接口。范围视图是只读的，支持枚举、索引访问等操作，但不复制底层数据。

### 2. 内部工具

#### BinarySearch
二分查找工具类，提供了各种二分查找算法的实现，包括精确查找、边界查找、最接近查找等。针对整数键提供了优化版本。

#### ByteBufferWriter
字节缓冲区写入器，用于高效地构建字节数组。支持动态扩展缓冲区，提供了流式写入接口。

#### ExpandableArray
可扩展数组，用于处理未知大小的数据集合。在构建数据库时，如果数据源不是集合类型，使用可扩展数组来收集数据。

#### HeaderFormatterResolver
头部格式化器解析器，用于序列化和反序列化数据库头部信息。头部信息包含了表名和表数据在二进制数据中的位置信息。

#### InternStringResolver
字符串内化解析器，用于在反序列化时将字符串内化到字符串池中，减少内存占用。

### 3. 验证组件

#### Validator
验证器类，提供了验证过程中的上下文和方法。验证器可以访问当前验证的数据、关联表、验证结果等，提供了丰富的验证 API。

#### ValidatableSet
可验证集合类，提供了表级别的验证功能。支持过滤、唯一性验证等操作，可以链式调用多个验证方法。

#### ReferenceSet
引用集合类，提供了跨表验证的功能。用于验证外键引用的完整性，确保引用的数据在关联表中存在。

#### ValidationDatabase
验证数据库类，提供了验证过程中的数据库访问接口。验证器可以通过验证数据库访问所有表的数据。

#### ValidateResult
验证结果类，用于收集和格式化验证错误信息。提供了错误列表访问、格式化输出等功能。

### 4. 源代码生成组件

#### MasterMemoryGenerator
源代码生成器主类，使用 Roslyn 增量生成器技术。扫描所有标记了 `MemoryTableAttribute` 的类型，生成相应的代码。

#### GenerationContext
生成上下文类，包含了代码生成所需的所有信息，包括类型信息、属性信息、索引信息等。用于在生成过程中传递上下文信息。

#### 模板类
使用 T4 模板技术生成代码，包括数据库构建器模板、数据库模板、表模板、不可变构建器模板、MessagePack 解析器模板等。模板提供了灵活的代码生成方式。

#### CodeGenerator
代码生成器类，负责解析类型信息、提取属性信息、构建索引信息等，为代码生成准备上下文。

## 属性系统

MasterMemory 提供了丰富的属性来控制数据库的行为：

### 1. 类型级别属性

#### MemoryTableAttribute
标记类型为内存表，必须指定表名。只有标记了这个属性的类型才会被源代码生成器处理，生成相应的表类和数据库代码。

### 2. 成员级别属性

#### PrimaryKeyAttribute
标记属性为主键，可以指定键的顺序（用于复合主键）。每个表必须定义主键，主键用于精确查找和唯一性约束。

#### SecondaryKeyAttribute
标记属性为次键索引，必须指定索引编号和键的顺序（用于复合索引）。一个表可以定义多个次键索引，支持灵活的查询需求。

#### NonUniqueAttribute
标记索引为非唯一索引，允许索引键值重复。非唯一索引支持批量查询，返回所有匹配的记录。

#### StringComparisonOptionAttribute
指定字符串字段的比较方式，可以选择不同的字符串比较规则。影响索引排序和查询时的键值比较。

## 使用场景

MasterMemory 适用于以下场景：

### 1. 游戏配置数据管理
游戏中的配置数据（如物品数据、技能数据、关卡数据等）通常是不变的，适合使用 MasterMemory 进行管理。可以高效地查询和访问配置数据，支持复杂的查询需求。

### 2. 静态数据查询
任何需要快速查询静态数据的场景，如字典数据、参考数据等。MasterMemory 提供了高效的查询性能，适合高频查询场景。

### 3. 数据驱动的游戏开发
数据驱动的游戏开发需要将数据与代码分离，MasterMemory 提供了类型安全的数据访问接口，支持在运行时加载和查询数据。

### 4. 数据验证和完整性检查
在数据构建阶段，MasterMemory 的数据验证系统可以确保数据的完整性和正确性，避免运行时错误。

### 5. 数据序列化和传输
使用 MessagePack 序列化，可以将数据库序列化为紧凑的二进制格式，适合网络传输和文件存储。

### 6. 增量数据更新
使用不可变构建器，可以基于现有数据库创建更新版本，支持增量更新和版本管理。

### 7. 跨平台数据共享
使用二进制序列化格式，可以在不同平台之间共享数据，支持跨平台游戏开发。

## 设计原则

### 1. 不可变性优先
所有数据都是不可变的，确保了数据的一致性和线程安全性。这是框架设计的核心原则。

### 2. 类型安全
通过源代码生成和泛型设计，提供了编译时类型检查，避免了运行时类型错误。

### 3. 性能优先
所有设计都考虑了性能因素，使用高效的算法和数据结构，最小化内存分配和 CPU 开销。

### 4. 易于使用
通过源代码生成，自动生成所有必要的代码，开发者只需定义数据类和标记属性，即可使用完整的数据库功能。

### 5. 可扩展性
提供了丰富的扩展点，支持自定义比较器、格式化器等，可以灵活扩展框架的功能。

### 6. Unity 优化
针对 Unity 平台进行了特殊优化，确保在 Unity 环境中有良好的性能和兼容性。

## 性能特点

MasterMemory 具有以下性能特点：

### 1. 高效查询
使用二分查找算法，查询时间复杂度为 O(log n)，即使在大量数据中也能快速查询。

### 2. 零拷贝访问
支持直接访问原始数据数组，避免了额外的内存拷贝，提供了接近原生数组访问的性能。

### 3. 紧凑存储
使用 MessagePack 序列化和 LZ4 压缩，大幅减少内存占用和数据传输大小。

### 4. 快速加载
支持并行加载，可以充分利用多核 CPU 的性能优势，快速加载大型数据库。

### 5. 低内存开销
不可变设计和高效的数据结构，最小化内存占用。字符串内化等功能进一步减少内存使用。

### 6. 无运行时反射
通过源代码生成，所有代码都在编译时生成，避免了运行时反射的性能开销。

## 总结

MasterMemory 是一个功能完整、性能优异的内存数据库框架，为 C# 和 Unity 应用提供了强大的静态数据管理能力。通过不可变设计、源代码生成、索引系统、数据验证等核心功能，它能够满足从简单配置数据到复杂静态数据库的各种需求。框架的设计注重类型安全、性能和易用性，是构建数据驱动应用程序的理想选择。无论是游戏开发、配置管理还是静态数据查询，MasterMemory 都能提供优秀的性能和开发体验。
