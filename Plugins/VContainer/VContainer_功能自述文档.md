# VContainer 依赖注入框架功能自述文档

## 概述

VContainer 是一个专为 Unity 设计的高性能依赖注入（Dependency Injection，DI）框架。它提供了简洁易用的 API，帮助开发者实现松耦合、可测试、可维护的代码架构。VContainer 通过自动管理对象的创建、依赖关系和生命周期，显著简化了 Unity 项目的依赖管理，是构建大型 Unity 项目的理想选择。

## 核心特性

### 一、依赖注入系统

VContainer 提供了完整的依赖注入功能，支持多种注入方式：

#### 1. 构造函数注入
框架会自动识别类的构造函数，并通过容器解析并注入所需的依赖。这是推荐的注入方式，因为它确保了对象在创建时所有依赖都已就绪。

#### 2. 字段注入
通过 `[Inject]` 属性标记字段，框架会在对象创建后自动注入依赖。这种方式适用于需要在运行时动态注入的场景。

#### 3. 属性注入
通过 `[Inject]` 属性标记属性，框架会在对象创建后自动注入依赖。属性注入提供了更好的封装性。

#### 4. 方法注入
通过 `[Inject]` 属性标记方法，框架会在对象创建后调用该方法并注入参数。方法注入适用于需要在注入时执行特定逻辑的场景。

#### 5. 参数注入
在注册时可以通过 `WithParameter` 方法指定特定参数的值，支持按名称、按类型或通过工厂函数注入参数。

#### 6. 键值注入
通过 `KeyAttribute` 和 `Keyed` 方法，可以为同一类型的多个注册指定不同的键值，实现多态注入。

### 二、生命周期管理

VContainer 提供了三种生命周期模式：

#### 1. Transient（瞬态）
每次解析时都会创建新的实例。适用于无状态的服务或每次都需要新实例的场景。

#### 2. Singleton（单例）
整个容器生命周期内只创建一个实例，所有解析请求都返回同一个实例。适用于需要共享状态的服务。

#### 3. Scoped（作用域）
在作用域内保持单例，不同作用域之间相互独立。适用于需要按场景、按模块隔离的服务。

### 三、作用域系统

VContainer 提供了强大的作用域系统，支持创建嵌套的作用域：

#### 1. 根容器
最顶层的容器，管理全局单例和根作用域。

#### 2. 子作用域
可以从父容器创建子作用域，子作用域可以访问父作用域中的注册，但拥有自己的作用域单例。

#### 3. 作用域查找
解析依赖时会自动在作用域链中向上查找，直到找到合适的注册。

### 四、Unity 集成功能

VContainer 深度集成 Unity，提供了丰富的 Unity 特定功能：

#### 1. LifetimeScope
Unity 组件，用于在场景中管理依赖注入容器。支持父子关系、自动构建、自动注入等功能。

#### 2. 组件注册
提供了多种方式注册 Unity 组件：
- 注册现有组件实例
- 在场景层次结构中查找组件
- 在新 GameObject 上创建组件
- 从预制体实例化组件

#### 3. Entry Points（入口点）
提供了一系列接口，用于在 Unity 生命周期中自动执行代码：
- `IInitializable` - 初始化时调用
- `IPostInitializable` - 初始化后调用
- `IStartable` - Start 时调用
- `IPostStartable` - Start 后调用
- `ITickable` - Update 时调用
- `IPostTickable` - Update 后调用
- `IFixedTickable` - FixedUpdate 时调用
- `IPostFixedTickable` - FixedUpdate 后调用
- `ILateTickable` - LateUpdate 时调用
- `IPostLateTickable` - LateUpdate 后调用
- `IAsyncStartable` - 异步启动（支持 UniTask 和 Unity 2023.1+）

#### 4. GameObject 注入
可以自动为 GameObject 及其子对象的所有 MonoBehaviour 组件注入依赖。

#### 5. Prefab 实例化
提供了增强的实例化方法，自动处理依赖注入，支持位置、旋转、父对象等参数。

### 五、注册系统

VContainer 提供了灵活的注册 API：

#### 1. 类型注册
可以注册类型及其实现，支持接口到实现的映射。

#### 2. 实例注册
可以注册已创建的实例，适用于需要在外部创建的对象。

#### 3. 工厂注册
可以注册工厂函数，支持通过函数创建实例，提供最大的灵活性。

#### 4. 泛型注册
支持开放泛型类型的注册，可以注册泛型类型定义。

#### 5. 多接口注册
一个实现可以注册为多个接口类型。

#### 6. 自动接口注册
可以自动将实现注册为其实现的所有接口。

### 六、Installer 模式

VContainer 支持 Installer 模式，用于组织和管理注册代码：

#### 1. IInstaller 接口
实现该接口可以创建可重用的安装器，将相关的注册逻辑组织在一起。

#### 2. ActionInstaller
通过委托快速创建安装器，适用于简单的注册场景。

#### 3. 安装器组合
可以在 LifetimeScope 中组合多个安装器，实现模块化的依赖配置。

### 七、诊断系统

VContainer 提供了强大的诊断工具，帮助开发者理解和调试依赖关系：

#### 1. 诊断收集器
可以收集注册和解析信息，包括调用堆栈、依赖关系等。

#### 2. 诊断窗口
Unity 编辑器窗口，可视化显示：
- 所有注册的类型和生命周期
- 依赖关系图
- 解析路径
- 实例引用
- 注册位置和堆栈跟踪

#### 3. 依赖关系追踪
可以追踪每个注册的依赖关系，帮助发现循环依赖和缺失的注册。

### 八、ECS 集成（可选）

当项目中包含 Unity ECS 包时，VContainer 提供了 ECS 系统集成：

#### 1. World 注册
可以注册和管理 ECS World。

#### 2. System 注册
可以注册 ComponentSystemBase 和 ISystem，支持分组和排序。

#### 3. 系统生命周期
自动管理 ECS 系统的生命周期，与 Unity 生命周期集成。

### 九、性能优化

VContainer 在性能方面做了大量优化：

#### 1. 反射缓存
使用反射缓存减少反射调用开销。

#### 2. 内联优化
关键路径使用内联优化，减少方法调用开销。

#### 3. 并发安全
使用并发集合保证线程安全，支持多线程场景。

#### 4. 内存管理
使用对象池和延迟初始化减少内存分配。

### 十、扩展性

VContainer 提供了良好的扩展性：

#### 1. 自定义 Provider
可以实现自定义的实例提供者，支持特殊的创建逻辑。

#### 2. 自定义 Injector
可以实现自定义的注入器，支持特殊的注入逻辑。

#### 3. 构建回调
可以在容器构建时注册回调，执行额外的初始化逻辑。

#### 4. 销毁回调
可以在容器销毁时注册回调，执行清理逻辑。

## 技术架构

### 1. 核心组件

#### Container（容器）
负责管理注册和解析的核心组件。维护注册表、实例缓存、作用域关系等。

#### ContainerBuilder（容器构建器）
用于构建容器的构建器模式实现。收集注册信息，构建注册表，创建容器实例。

#### Registry（注册表）
存储所有注册信息的核心数据结构。提供高效的查找和匹配功能。

#### Registration（注册信息）
封装单个注册的所有信息，包括类型、生命周期、提供者、键值等。

### 2. 注入系统

#### ReflectionInjector（反射注入器）
使用反射分析类型，构建注入器，在运行时执行注入。

#### InjectorCache（注入器缓存）
缓存已构建的注入器，避免重复的反射分析。

#### TypeAnalyzer（类型分析器）
分析类型的依赖关系，检测循环依赖，验证注册完整性。

### 3. 实例提供系统

#### InstanceProvider（实例提供者）
负责创建和管理实例的抽象接口。

#### 各种 Provider 实现
- `InstanceProvider` - 标准实例提供者
- `ExistingInstanceProvider` - 现有实例提供者
- `FuncInstanceProvider` - 工厂函数提供者
- `ComponentProvider` - Unity 组件提供者

### 4. Unity 集成层

#### LifetimeScope
Unity MonoBehaviour 组件，管理容器的生命周期，与 Unity 场景系统集成。

#### EntryPointDispatcher
负责调度和执行所有 Entry Point 接口的实现。

#### PlayerLoopHelper
与 Unity PlayerLoop 系统集成，在正确的时机执行更新循环。

## 使用场景

### 1. 游戏架构
使用 VContainer 构建清晰的游戏架构，分离业务逻辑和基础设施代码。

### 2. 服务定位
通过依赖注入实现服务定位模式，避免全局单例和静态引用。

### 3. 单元测试
依赖注入使得代码易于测试，可以轻松替换依赖进行单元测试。

### 4. 模块化开发
通过 Installer 模式实现模块化开发，不同模块可以独立配置依赖。

### 5. 场景管理
使用 LifetimeScope 管理场景级别的依赖，实现场景间的依赖隔离。

### 6. UI 系统
通过依赖注入管理 UI 控制器和视图，实现清晰的 UI 架构。

### 7. 数据管理
通过依赖注入管理数据服务和仓储，实现数据访问的抽象。

## 优势特点

1. **高性能**：经过精心优化，性能开销极小，适合游戏开发。
2. **易用性**：API 设计简洁直观，学习曲线平缓。
3. **Unity 集成**：深度集成 Unity，支持 Unity 特有的功能。
4. **类型安全**：编译时类型检查，减少运行时错误。
5. **诊断工具**：强大的诊断工具，帮助快速定位问题。
6. **灵活性**：支持多种注入方式和注册方式，适应各种场景。
7. **可扩展性**：良好的扩展性，可以自定义各种行为。
8. **文档完善**：提供详细的文档和示例。

## 最佳实践

### 1. 构造函数注入优先
优先使用构造函数注入，它确保了依赖的完整性和不可变性。

### 2. 接口编程
使用接口而非具体类型，提高代码的可测试性和可维护性。

### 3. 合理使用生命周期
根据对象的用途选择合适的生命周期，避免不必要的单例。

### 4. 使用 Installer
将注册逻辑组织到 Installer 中，提高代码的可维护性。

### 5. 启用诊断
在开发阶段启用诊断功能，帮助理解依赖关系。

### 6. 避免循环依赖
注意避免循环依赖，使用事件或回调解决相互依赖的问题。

### 7. 作用域隔离
合理使用作用域，实现不同模块间的依赖隔离。

## 总结

VContainer 是一个功能强大、性能优异、易于使用的 Unity 依赖注入框架。它通过自动管理依赖关系，显著简化了 Unity 项目的架构设计，提高了代码的可测试性和可维护性。无论是小型项目还是大型企业级项目，VContainer 都能提供可靠的依赖注入解决方案。

