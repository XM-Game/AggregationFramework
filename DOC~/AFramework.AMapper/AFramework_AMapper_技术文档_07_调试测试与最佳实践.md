# AFramework.AMapper 技术文档

## 第七部分：调试、测试与最佳实践

---

## 1. 理解映射执行

### 1.1 BuildExecutionPlan

查看映射的执行计划，这是调试映射问题的核心工具。

**使用方式**：
- var plan = config.BuildExecutionPlan(typeof(Source), typeof(Dest))

**返回内容**：
- Lambda 表达式树
- 完整的映射逻辑
- 包含所有条件、转换、空值检查

**执行计划包含**：
- 源对象空值检查
- 目标对象创建逻辑
- 成员映射表达式
- 条件映射逻辑
- 值转换器调用
- 循环引用处理

### 1.2 可视化执行计划

使用编辑器工具查看可读代码。

**工具**：
- AMapper 执行计划查看器（编辑器窗口）
- Debug.Log 输出表达式

**用途**：
- 理解实际映射逻辑
- 调试意外行为
- 性能分析
- 验证配置正确性

### 1.3 ProjectTo 表达式

查看投影生成的表达式。

**方式**：
- var expr = query.ProjectTo\<T\>().Expression

**用途**：
- 验证生成的查询
- 优化查询性能
- 确认字段选择

---

## 2. 配置验证详解

### 2.1 AssertConfigurationIsValid

验证所有映射配置的完整性。

**验证内容**：
- 目标成员都有映射源
- 类型转换可行
- 构造函数参数匹配
- 无重复配置

**使用时机**：
- 单元测试（推荐）
- 应用启动（开发环境）
- CI/CD 管道

### 2.2 验证特定映射

**按 TypeMap 验证**：
- config.AssertConfigurationIsValid(typeMap)

**按 Profile 验证**：
- config.AssertConfigurationIsValid("ProfileName")
- config.AssertConfigurationIsValid\<TProfile\>()

### 2.3 验证异常类型

**ConfigurationException**：
- 配置错误（未映射成员、无效转换）
- 包含详细的错误信息

**DuplicateTypeMapException**：
- 同一类型对在多个 Profile 中配置
- 包含重复的 Profile 名称

### 2.4 自定义验证

扩展验证逻辑。

**ValidationContext 结构**：

| 属性 | 说明 |
|------|------|
| Types | 当前验证的类型对 |
| MemberMap | 当前成员映射 |
| Exceptions | 异常收集列表 |
| TypeMap | 类型映射（可选） |

**注册方式**：
- cfg.Validators.Add(context => { ... })

---

## 3. 常见问题诊断

### 3.1 映射失败

**常见原因**：
- 缺少类型映射配置
- 属性名称不匹配
- 类型转换失败
- 构造函数参数不匹配

**诊断步骤**：
1. 检查异常消息和堆栈
2. 运行 AssertConfigurationIsValid
3. 查看 BuildExecutionPlan
4. 检查源对象数据

### 3.2 性能问题

**常见原因**：
- 首次映射编译开销
- 深层嵌套对象图
- 大量数据映射
- 复杂的值解析器

**诊断方法**：
- 使用 Unity Profiler
- 检查执行计划复杂度
- 监控内存使用和 GC
- 测量首次映射 vs 后续映射时间

**优化方向**：
- 使用 CompileMappings() 预编译
- 减少 MaxExecutionPlanDepth
- 使用 MapAtRuntime 减少计划大小
- 考虑 ProjectTo 替代内存映射

### 3.3 空引用异常

**常见原因**：
- 源对象为 null
- 嵌套属性为 null
- 条件映射逻辑问题
- 值解析器返回 null

**解决方案**：
- 使用 PreCondition 检查
- 配置 AllowNullDestinationValues
- 使用 NullSubstitute
- 检查源数据完整性

### 3.4 循环引用问题

**症状**：
- StackOverflowException
- 无限递归
- 内存溢出

**解决方案**：
- AMapper 自动检测并设置 PreserveReferences
- 手动配置 MaxDepth
- 重新设计对象模型
- 使用 Ignore 打破循环

### 3.5 Unity 特定问题

**常见问题**：
- IL2CPP 编译错误
- 反射限制
- 泛型类型问题

**解决方案**：
- 使用预编译映射
- 配置 link.xml 保留类型
- 避免运行时代码生成

---

## 4. 单元测试策略

### 4.1 测试配置有效性

**基本测试模式**：
- 创建 MapperConfiguration
- 调用 AssertConfigurationIsValid
- 验证无异常抛出

**测试组织**：
- 每个 Profile 一个测试类
- 或整体配置一个测试
- 使用测试夹具共享配置

### 4.2 测试映射结果

**测试内容**：
- 属性值正确映射
- 嵌套对象正确处理
- 集合正确转换
- 条件映射正确执行

**测试方法**：
- 准备源对象（Arrange）
- 执行映射（Act）
- 断言结果（Assert）

### 4.3 测试边界条件

**测试场景**：
- null 源对象
- 空集合
- 默认值
- 极端值
- 部分属性为 null

### 4.4 测试自定义组件

**测试对象**：
- IValueResolver 实现
- ITypeConverter 实现
- IMappingAction 实现
- 自定义 IObjectMapper

**测试方式**：
- 隔离测试组件逻辑
- 集成测试完整映射流程
- Mock 依赖项

### 4.5 Unity 测试集成

**测试框架**：
- Unity Test Framework
- NUnit 集成

**测试模式**：
- Edit Mode 测试：配置验证
- Play Mode 测试：运行时映射

---

## 5. 性能优化详解

### 5.1 预编译映射

**CompileMappings 方法**：
- 启动时编译所有映射
- 避免首次映射延迟
- 提前发现配置问题

**适用场景**：
- 大量映射配置
- 对首次响应敏感的应用
- 生产环境部署

**Unity 建议**：
- 在加载界面执行预编译
- 使用协程分帧编译
- 显示编译进度

### 5.2 减少执行计划大小

**MaxExecutionPlanDepth 配置**：
- 限制内联深度
- 减少编译时间
- 减少生成代码大小

**MapAtRuntime 配置**：
- 成员级运行时映射
- 不内联到执行计划
- 适合深层嵌套

### 5.3 避免不必要的功能

**性能影响功能**：
- PreserveReferences：增加缓存查找开销
- MaxDepth：增加深度检查开销
- 复杂条件映射：增加分支判断

**建议**：
- 仅在需要时启用
- 考虑重新设计模型
- 使用 Ignore 排除不需要的成员

### 5.4 对象池优化

**池化对象**：
- MappingContext
- 临时集合
- 目标对象（可选）

**配置方式**：
- cfg.UseObjectPool = true

### 5.5 缓存策略

**内置缓存**：
- TypeMap 缓存
- 执行计划缓存
- 投影表达式缓存

**最佳实践**：
- MapperConfiguration 作为单例
- 避免频繁创建配置
- 复用 IAMapper 实例

### 5.6 GC 优化

**减少分配**：
- 使用对象池
- 避免不必要的装箱
- 复用集合

**监控建议**：
- 使用 Unity Profiler
- 关注 GC.Alloc
- 检查热路径分配

---

## 6. 最佳实践

### 6.1 配置组织

**使用 Profile**：
- 按领域/模块组织
- 保持配置内聚
- 便于维护

**避免**：
- 单个巨大配置
- 分散的配置

### 6.2 映射设计

**扁平化 DTO**：
- 简化目标结构
- 利用自动扁平化

**避免**：
- 过深嵌套
- 循环引用
- 复杂继承

### 6.3 命名约定

**遵循约定**：
- 一致的命名风格
- 利用自动匹配

**减少配置**：
- 约定优于配置
- 只配置例外情况

### 6.4 验证策略

**开发阶段**：
- 启用完整验证
- 快速发现问题

**生产环境**：
- 移除验证调用
- 使用条件编译

### 6.5 依赖注入

**推荐方式**：
- 使用 RegisterAMapper
- 注入 IAMapper

**避免**：
- 静态 Mapper
- 手动创建实例

---

## 7. 常见模式

### 7.1 DTO 模式

**用途**：
- 数据传输
- API 响应
- 视图模型

**设计原则**：
- 扁平结构
- 只包含需要的数据
- 无业务逻辑

### 7.2 双向映射

**使用 ReverseMap**：
- 自动创建反向映射
- 支持反扁平化

**注意事项**：
- 验证反向映射
- 可能需要自定义

### 7.3 继承映射

**使用 Include**：
- 复用基类配置
- 支持多态

**设计考虑**：
- 保持继承简单
- 避免深层继承

### 7.4 条件映射

**使用场景**：
- 根据条件映射
- 默认值处理

**最佳实践**：
- 使用 PreCondition 优化性能
- 保持条件简单

---

## 8. 反模式

### 8.1 过度配置

**问题**：
- 配置每个属性
- 忽略约定

**解决**：
- 利用自动匹配
- 只配置例外

### 8.2 业务逻辑在映射中

**问题**：
- 映射包含业务逻辑
- 难以测试和维护

**解决**：
- 映射只做数据转换
- 业务逻辑放在服务层

### 8.3 忽略验证

**问题**：
- 不验证配置
- 运行时才发现问题

**解决**：
- 始终验证配置
- 添加单元测试

### 8.4 滥用 Ignore

**问题**：
- 大量 Ignore 配置
- 隐藏设计问题

**解决**：
- 重新设计 DTO
- 使用 MemberList.None

### 8.5 复杂解析器

**问题**：
- 解析器包含复杂逻辑
- 难以测试

**解决**：
- 保持解析器简单
- 复杂逻辑移至服务

---

## 9. Unity 项目特别建议

### 9.1 推荐使用场景

**适合 AMapper**：
- 网络数据转换（服务器响应 → 游戏对象）
- 配置数据映射（ScriptableObject → 运行时数据）
- 存档系统（游戏状态 → 存档数据）
- UI 数据绑定（模型 → ViewModel）

### 9.2 谨慎使用场景

**可能不需要 AMapper**：
- 简单的属性复制
- 性能关键的热路径
- 实时更新的数据

### 9.3 IL2CPP 注意事项

**预编译要求**：
- 在编辑器中预编译所有映射
- 配置 link.xml 保留必要类型
- 避免运行时泛型实例化

**link.xml 配置**：
- 保留 AMapper 程序集
- 保留自定义解析器
- 保留映射类型

### 9.4 移动平台优化

**内存优化**：
- 使用对象池
- 限制映射深度
- 避免大对象映射

**性能优化**：
- 预编译映射
- 分帧处理大量映射
- 使用 ProjectTo 减少数据加载

---

## 10. 资源与支持

### 10.1 文档资源

**技术文档**：
- 本系列文档
- API 参考文档
- 示例项目

### 10.2 调试工具

**编辑器工具**：
- AMapper 配置窗口
- 执行计划查看器
- Profile 检视器

### 10.3 社区支持

**获取帮助**：
- GitHub Issues
- 技术论坛
- 示例代码库

---

## 11. 总结

### 11.1 核心要点

- 约定优于配置
- 使用 Profile 组织配置
- 始终验证配置
- 利用 ProjectTo 优化查询
- 保持映射简单

### 11.2 适用场景

**推荐使用**：
- DTO 转换
- 网络数据映射
- 配置数据转换
- 存档系统

**谨慎使用**：
- 复杂业务转换
- 性能关键路径
- 简单赋值场景

### 11.3 技术选型建议

**选择 AMapper 当**：
- 有大量类似结构的映射
- 需要约定驱动的映射
- 需要 Unity 类型支持

**考虑替代方案当**：
- 映射非常简单
- 需要极致性能
- 映射逻辑复杂多变

---

*下一部分：成员配置与表达式系统*
